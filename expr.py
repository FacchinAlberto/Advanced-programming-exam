# ALBERTO FACCHIN SM3201282

class EmptyStackException(Exception):
    pass


class TextException(Exception):
    pass


class MissingVariableException(Exception):
    pass

# Stack class contains "classical" push and pop operations and two dunder methods(init and str)
class Stack:
    def __init__(self):
        self.data = []  # allocate an empty list

    def push(self, x):
        self.data.append(x) # append the element in the list

    def pop(self):
        if self.data == []:
            raise EmptyStackException   # rasie an exception when try to pop an empty stack
        res = self.data[-1]
        self.data = self.data[0:-1]
        return res

    def __str__(self):
        return " ".join([str(s) for s in self.data])

# The Expression class contains a class method (from_program()) which takes as parameters the object itself,
# the instructions string (text) and the dictionary with the associations between a keyword and its relative class
class Expression:
    def __init__(self):
        pass

    @classmethod
    def from_program(cls, text, dispatch):
        stack = Stack()       
        # preliminary check of the text string (if it is None or if the string is empty) 
        if text is None or len(text.split()) == 0:
            raise TextException('ERROR: invalid expression')
        environment = text.split()  # split the text using the spaces (" ") as separator
        for elem in environment:    # for each element found in the text string
            if elem.isnumeric() or (elem[0] == '-' and elem[1:].isnumeric()):    # check if elem is a number (positive or negative)
                stack.push(Constant(elem))
            elif elem in dispatch:  # check if elem is a "keyword" associated with a class
                operation_class = dispatch.get(elem)    # get the value of the dictionary (so the class)
                arity = operation_class.arity   # get the arity of the operation
                operators = []  # list of the operators
                for i in range(arity):   # iterate over the arity of the class (e.g. Addition.arity = 2)
                    operators += [stack.pop()]
                operation_object = operation_class(operators)   # define the operation object and pass the operators to be used
                stack.push(operation_object)
            elif elem.startswith('prog'):   # check if the elem starts with prog
                try:
                    n = int(elem[4])  # in prog3, elem[4] corresponds to the number 3 (expressions to be evaluated)
                    if n == 0:      # check if elem is prog0
                        print('WARNING: prog0 is not a valid instruction (ignored it)')
                    else:
                        expressions = [stack.pop() for i in range(n)]   # pop n expressions
                        stack.push(Sequence([expressions, n]))   
                except ValueError:
                    print(f'ERROR: {elem[4]} is not a valid number of expressions to evaluate') # to catch the exception generated by (e.g.) "progt"
            elif elem.isalpha():    # check if elem is a string
                stack.push(Variable(elem))
            else:
                raise ValueError(f"ERROR: invalid element: {elem}")
        return stack.pop()
    
    def evaluate(self, env):
        pass

# class for every variable, e.g. x, y, var, etc.
class Variable(Expression):
    def __init__(self, name):
        self.name = name

    def evaluate(self, env):
        # check if the variable is in the environment, else raise an error (cannot evaluate a non-existing variable)
        for variable in env:
            if self.name == variable:   # check if the variable name is equal to one of the keys in the dictionary
                return env.get(variable)    # return the value of the relative dictionary's element if the key is equal to the var name
        raise MissingVariableException(f'ERROR: missing variable ({self.name}) in the environment')

    def __str__(self):
        return f'{self.name}'


# class for numeric values
class Constant(Expression):
    def __init__(self, value):
        self.value = value

    def evaluate(self, env):
        return self.value   # return the value of the constant itself

    def __str__(self):
        return f'{self.value}'


# class for Zero, Unary, Binary, Ternary and Quaternary operations
class Operation(Expression):
    def __init__(self, args):
        self.args = args

    def evaluate(self, env):        
        # args is a list of evaluation of the arguments passed to the constructor of the class
        args = [arg.evaluate(env) for arg in self.args]
        return self.op(*args) # self.op(*args) does the same of self.op(args[0], args[1]) e.g. in a binary operation

    def op(self, *args):
        pass

    def __str__(self):
        return ''.join([str(arg) for arg in self.args])


# for operations that need 0 arguments
class ZeroOp(Operation):
    arity = 0


# for operations that need 1 argument
class UnaryOp(Operation):
    arity = 1
    

# for operations that need 2 arguments
class BinaryOp(Operation):
    arity = 2


# for operations that need 3 arguments
class TernaryOp(Operation):
    arity = 3


# for operations that need 4 arguments
class QuaternaryOp(Operation):
    arity = 4


# MATHEMATICAL OPERATIONS________________________________________________________________________________________________________________________________

# class for the addition operation, associated to the "+" symbol
class Addition(BinaryOp):
    def op(self, x, y):
        return float(x) + float(y)
    
    def __str__(self):
        return f'(+ {self.args[0]} {self.args[1]})'


# class for the subtraction operation, associated to the "-" symbol
class Subtraction(BinaryOp):
    def op(self, x, y):
        return float(x) - float(y)
    
    def __str__(self):
        return f'(- {self.args[0]} {self.args[1]})'


# class for the division operation, associated to the "/" symbol.
# Here is necessary to handle divisions by zero. 
class Division(BinaryOp):
    def op(self, x, y):
        try: 
            return float(x)/float(y)
        except ZeroDivisionError as e:
            print(f'ERROR: cannot divide by zero ({e})')    # catch the ZeroDivisionError if y == 0
    
    def __str__(self):
        return f'(/ {self.args[0]} {self.args[1]})'


# class for the multiplication operation, associated to the "*" symbol
class Multiplication(BinaryOp):
    def op(self, x, y):
        return float(x)*float(y)
    
    def __str__(self):
        return f'(* {self.args[0]} {self.args[1]})'


# class for the power operation, associated to the "**" symbol
class Power(BinaryOp):
    def op(self, x, y):
        return float(x)**float(y)
    
    def __str__(self):
        return f'(** {self.args[0]} {self.args[1]})'


# class for the modulus operation, associated to the "%" symbol
class Modulus(BinaryOp):
    def op(self, x, y):
        return float(x)%float(y)
    
    def __str__(self):
        return f'(% {self.args[0]} {self.args[1]})'


# class for the reciprocal operation, associated to the "1/" symbol.
# Also in this class is needed to manage zero division errors.
class Reciprocal(UnaryOp):    
    def op(self, x):
        try: 
            return 1/float(x)
        except ZeroDivisionError as e:
            print(f'ERROR: cannot divide by zero ({e})')
    
    def __str__(self):
        return f'(1/ {self.args[0]})'


# class for the absolute value operation, associated to the "abs" symbol
class AbsoluteValue(UnaryOp):
    def op(self, x):
        return abs(float(x))
    
    def __str__(self):
        return f'(abs {self.args[0]})'


# LOGICAL OPERATIONS_________________________________________________________________________________________________________________________________

# class for the ">" logic operator. Every operation of this type returns a boolean value (True/False)
class GreaterThan(BinaryOp):
    def op(self, x, y):
        return float(x) > float(y)
    
    def __str__(self):
        return f'(> {self.args[0]} {self.args[1]})'


# class for the ">=" logic operator. Every operation of this type returns a boolean value (True/False)
class GreaterOrEqual(BinaryOp):
    def op(self, x, y):
        return float(x) >= float(y)
    
    def __str__(self):
        return f'(>= {self.args[0]} {self.args[1]})'


# class for the "=" logic operator. Every operation of this type returns a boolean value (True/False)
class Equality(BinaryOp):
    def op(self, x, y):
        return float(x) == float(y)
    
    def __str__(self):
        return f'(= {self.args[0]} {self.args[1]})'


# class for the "!=" logic operator. Every operation of this type returns a boolean value (True/False)
class Inequality(BinaryOp):
    def op(self, x, y):
        return float(x) != float(y)
    
    def __str__(self):
        return f'(!= {self.args[0]} {self.args[1]})'


# class for the "<" logic operator. Every operation of this type returns a boolean value (True/False)
class LowerThan(BinaryOp):
    def op(self, x, y):
        return float(x) < float(y)
    
    def __str__(self):
        return f'(< {self.args[0]} {self.args[1]})'


# class for the "<=" logic operator. Every operation of this type returns a boolean value (True/False)
class LowerOrEqual(BinaryOp):
    def op(self, x, y):
        return float(x) <= float(y)
    
    def __str__(self):
        return f'(<= {self.args[0]} {self.args[1]})'


# VARIABLES ALLOCATION______________________________________________________________________________________________________________________________

# class for the variable allocations ("alloc" keyword). The syntax is "var alloc" where var is the name of the variable.
class VariableAlloc(UnaryOp):
    def evaluate(self, env):
        var = self.args[0]
        if isinstance(var, Variable):   # firstly check if var is really a variable
            if var.name in env:         # if the variable is already in the environment pass, it's not necessary to allocate it again
                # print(f'WARNING: variable {var.name} already allocated (use setq to modify its value)')
                pass
            else:
                env[var.name] = 0   # else the variable is allocated in the environment
        else:
            raise TypeError(f'ERROR: wrong type, {var} is not a variable')
    
    def __str__(self):
        return f'({self.args[0]} alloc)'


# class for the array allocations ("valloc" keyword). The syntax is "n var valloc" where var is the name of the variable (array)
# and n is its dimension.
class ArrayAlloc(BinaryOp):
    def evaluate(self, env):
        var = self.args[0]
        n = self.args[1]      
        # try to convert n into an int, because it's impossible to create an array with a number of elements equal to a string
        try:
            n = int(n.evaluate(env))
        
            if n < 0:   # check if n is negative, as before it's impossible to create an array of (e.g.) -3 elements
                raise ValueError(f'ERROR: impossible to create an array of lenght {n}')  
            
            if isinstance(var, Variable):   # check if var is really a variable
                env[var.name] = []  # create the array (better to say the list)
                for i in range(n):
                    env[var.name].append(0) # assigning to every item 0 value
            else:
                raise TypeError(f'ERROR: wrong type, {var} is not a variable')
        except TypeError as e:
            print(f'ERROR: {n} cannot be used as array dimension')
    
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} valloc)'


# class for the variable's value assignment ("setq" keyword). The syntax is "expr x setq" where expr is the expression
# and x is the name of the variable whose value needs to be modified.
class SetVariable(BinaryOp):
    def evaluate(self, env):
        x = self.args[0]
        expr = self.args[1]
        
        if isinstance(x, Variable):     # check if x is really a variable
            # if the variable has been already allocated it is possible to modify its value, else it is raised
            # an exception (variable must be allocated before assigning a value)
            if x.name in env:
                env[x.name] = expr.evaluate(env)
                return expr.evaluate(env)
            else:
                raise ValueError(f'ERROR: variable {x.name} must be allocated before assigning a value')
        else:
            raise TypeError(f'ERROR: wrong type, {x} is not a variable')
    
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} setq)'


# class for the array's value assignment ("setv" keyword). The syntax is "expr n x setv" where expr is the expression
# and x is the name of the array whose n^th value needs to be modified. It is needed to handle the "out of bound" index error.
class SetArray(TernaryOp):
    def evaluate(self, env):
        x = self.args[0]
        n = self.args[1]
        expr = self.args[2]
        
        n = int(n.evaluate(env))    # decided to do not check if n < 0 in order to permit to modify (e.g.) the last item by using -1 index
        if isinstance(x, Variable):
            try: 
                env[x.name][n] = expr.evaluate(env) # modify the n^th value of the array (list)
                return expr.evaluate(env)   # return the new value
            except IndexError:
                print(f'ERROR: index {n} is out of bound for the array {x.name} (usable indexes: from 0 to {len(env[x.name]) - 1}). Array not modified')
        else:
            raise TypeError(f'ERROR: wrong type, {self.args[0]} is not a variable')
    
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} {self.args[2]} setv)'
    

# SEQUENCES_______________________________________________________________________________________________________________________________________

# this class is used when in the instructions' string appears the "prog" keyword.
# progn evaluates the previous n expressions, the syntax could be:
# - expr1 expr2 prog2 
# - expr1 expr2 expr3 prog3 
# - expr1 expr2 expr3 expr4 prog4 
class Sequence(Expression):
    def __init__(self, args):   # args = [expr, n]
        self.args = args
        self.expr = self.args[0]
        self.n = self.args[1]   # n is the number of expressions to be evaluated

    def evaluate(self, env):        
        for i in range(self.n):
            self.expr[i].evaluate(env)   # for each expression, evaluate it

    def op(self, *args):
        pass

    def __str__(self):
        output = ''
        for i in range(self.n):
            output += f'{self.expr[i]}' # string concatenation, every expression is put between brackets
        return f'({output} prog{self.args[1]})'


# CONDITIONS AND ITERATIONS________________________________________________________________________________________________________________________

# the following class is used when the keyword "if" occurs in the text.
# The syntax is "if-no if-yes cond if", if the cond evaluation returns a True value then it is 
# evaluated the if-yes expression otherwise the if-no one. The evaluate() function returns the expression evaluated.
class IfCondition(TernaryOp):
    def evaluate(self, env):
        cond = self.args[0]
        if_yes = self.args[1]
        if_no = self.args[2]
        if cond.evaluate(env) is True:  # check if the cond evaluation returns True
            return if_yes.evaluate(env) # return if_yes evaluation
        else:
            return if_no.evaluate(env)  # return if_no evaluation
        
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} {self.args[2]} if)'
    
    
# class used when the keyword "while" occurs in the text.
# The syntax is "expr cond while" and while cond evaluation returns a True value then it is 
# evaluated the "expr" expression. The evaluate() function does not return something.
class WhileCycle(BinaryOp):
    def evaluate(self, env):
        cond = self.args[0]
        expr = self.args[1]
        while cond.evaluate(env) is True:   # while the condition is True
            expr.evaluate(env)  # continue to evaluate the expression
        
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} while)'


# class used when the keyword "for" occurs in the text.
# The syntax is "expr end start i for" where i is the variable name, start and end are used to form a range of values
# to be assigned to variable. Then the expression is evaluated for each value in [start, end).
class ForCycle(QuaternaryOp):
    def evaluate(self, env):
        var = self.args[0]
        try:    # converting start and end into numeric integer values
            start = int(self.args[1].evaluate(env))
            end = int(self.args[2].evaluate(env))
        except TypeError:
            print(f'ERROR: invalid values for start = {start} or end = {end}')  # catch if start or end is a string (or both two sre string)
        expr = self.args[3]
               
        for i in range(start, end):
            env[var.name] = i   # set the value of the variable
            expr.evaluate(env)  # evaluate the expression using the new variable's value
        
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} {self.args[2]} {self.args[3]} for)'


# SUBROUTINE_______________________________________________________________________________________________________________________________________

# class for subroutine definitions, used with the instruction "defsub".
# The syntax is "expr f defsub" and associates expr (an expression) to a new variable (whose name is f, not literally "f")
class SubroutineDefinition(BinaryOp):
    def evaluate(self, env):
        f = self.args[0]
        expr = self.args[1]
        env[f.name] = expr
        # does not return something, just associates the variable name to a value
        
    def __str__(self):
        return f'({self.args[0]} {self.args[1]} defsub)'


# class used when evaluating the expression associated to the f variable.
# The syntax is "f call", so the instruction keyword is "call".
class Call(UnaryOp):
    def evaluate(self, env):
        f = self.args[0]
        env[f.name].evaluate(env) # evaluate the expression
        
    def __str__(self):
        return f'({self.args[0]} call)'


# ADDITIONAL FEATURES______________________________________________________________________________________________________________________________

# class used for implementing a "classical" print function.
# The syntax is "expr print" where "expr" is an expression and "print" is the instruction keyword.
# The evaluate() function prints the evaluation of the expression and returns it.
class Print(UnaryOp):
    def evaluate(self, env):
        expr = self.args[0]
        print(f'{expr} print: {expr.evaluate(env)}')
        return expr.evaluate(env)
        
    def __str__(self):
        return f'({self.args[0]} print)'


# class for doing nothing, in the sense that if appears the keyword "nop" in the text, the program has to do no operations.
class NoOperation(ZeroOp):
    def evaluate(self, env):
        return
        
    def __str__(self):
        return f'(nop)'


# MAIN_____________________________________________________________________________________________________________________________________________
d = {"+": Addition, "*": Multiplication, "**": Power, "-": Subtraction, "/": Division, "1/": Reciprocal, "%": Modulus, "abs": AbsoluteValue, 
     ">": GreaterThan, ">=": GreaterOrEqual, "=": Equality, "!=": Inequality, "<": LowerThan, "<=": LowerOrEqual, 'alloc': VariableAlloc, 
     "valloc": ArrayAlloc, "setq": SetVariable, "setv": SetArray, "if": IfCondition, "while": WhileCycle, "for": ForCycle, "defsub": SubroutineDefinition, 
     "call": Call, "print": Print, "nop": NoOperation}

# instructions text examples
examples = ["2 3 + x * 6 5 - / abs 2 ** y 1/ + 1/ 3 x setq x alloc 7 y setq y alloc prog5",
            "x 1 + x setq x 10 > while x alloc prog2",
            "v print i i * i v setv prog2 10 0 i for 10 v valloc prog2",
            "x print f call x alloc x 4 + x setq f defsub prog4",
            "nop i print i x % 0 = if 1000 2 i for 783 x setq x alloc prog3",
            "nop x print prime if nop 0 0 != prime setq i x % 0 = if 1 x - 2 i for 0 0 = prime setq prime alloc prog4 100 2 x for", 
            "v print i j * 1 i - 10 * 1 j - + v setv 11 1 j for 11 1 i for 100 v valloc prog3", 
            "x print 1 3 x * + x setq 2 x / x setq 2 x % 0 = if prog2 1 x != while 50 x setq x alloc prog3"]

for i in range(len(examples)):
    print(f'\nEXAMPLE {i + 1}: {examples[i]}')
    e = Expression.from_program(examples[i], d)
    print(f'rpn: {e}')
    env = {}
    res = e.evaluate(env)
    print(f'environment: {env}')
    if res is not None:
        print(f'result: {res}')